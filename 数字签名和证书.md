上一讲我们学习了对称加密和非对称加密，以及两者结合起来的混合加密，实现了机密性

但仅有机密性，离安全还差很远，黑客虽然拿不到会话密钥，无法破解密文，但可以通过收集足够多的密文，再尝试着修改，重复后发送给服务器，因为没有完整性保证，服务器只能照单全收，然后他就可以通过服务器的相应获取进一步的线索，最后就会破解出明文，


另外黑客也可以伪造身份发布公钥，如果你拿到了假的公钥，混合加密完全失效了， 你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。

所以在机密性的基础上还必须加上完整性，身份认证等特性，才能实现真正的安全

### 摘要算法，

实现完整性的手段主要是摘要算法，也就是常说的哈希函数，它能够把任意长度的字符串压缩成固定长度，而且独一无二的字符串，就好像给这段数据生成了一个指纹

换一个角度，也可以把摘要算法理解成特殊的单向加密算法，它只有算法，没有密钥，加密后的数据无法被解密，不能从摘要推出密文

因为摘要算法对数据具有单向性和雪崩效应，输入的微小不同会导致输出的剧烈变化，所以被TLS用来生成伪随机数

### 完整性

摘要算法保证了数字摘要和原文是完全等价的，所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性

比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改。

不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性

所以，真正的完整性必须建立在机密性上，在混合加密系统里用会话秘钥加密消息和摘要，这样黑客无法得知明文，也就没办法动手脚了

这有个术语叫哈希消息认证码


客户端（数据+私钥加密（数据摘要））发送给服务端，服务器用公钥解密出（数据+私钥加密（数据摘要）），并验证数据和摘要

### 数字签名

加密算法结合摘要算法，我们的通信过程可以说是比较安全了，但这里还有漏洞，就是通信的两个端点

就像一开始说的黑客可以伪装成网站来窃取信息，而反过来，他可以伪装成你，向网站发送支付，转账等消息，网站没有办法确认你的身份（无法验证你的公钥）

现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖章，就能够证明这份文件的真实性

在TLS中我们使用非对称加密中的私钥再加上摘要算法，就能够实现数字签名，同时实现 身份认证和不可否认

数字签名的原理其实很简单，所有私钥只加密原文的摘要，这样运算量就很小，而且得到的数字签名也很小，方便保管好传输

签名和公钥一样完全公开，任何人都可以获取，但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，在对比原文验证完整性，就可以像签署文件一样证明消息确实是你发到

刚才的两个行为也有专业术语，叫做签名和验签

只要你和网站互相交换公钥，就可以用“签名”和“验签”来确认消息的真实性，因为私钥保密，黑客不能伪造签名，就能够保证通信双方的身份。

比如，你用自己的私钥签名一个消息“我是小明”。网站收到后用你的公钥验签，确认身份没问题，于是也用它的私钥签名消息“我是某宝”。你收到后再用它的公钥验一下，也没问题，这样你和网站就都知道对方不是假冒的，后面就可以用混合加密进行安全通信了。


### 数字证书和CA

到现在，这里还有一个公钥的信任问题，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说怎么判断这个公钥是你或淘宝的公钥呢

我们其实可以用类似密钥交换的方法来解决公钥认证的问题，用别的私钥来给公钥签名，显然，这又会陷入”无穷递归“

但这次实在是”没招了“，要终结这个”死循环“，就必须引入外力，找一个工人的可信的第三方，让他作为信任的起点，递归的终点，构建起公钥的信任链

这个第三方就是我们常说的CA（证书认证结构），它就像网络世界里的公安局，公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的

CA对公钥的签名认证是有格式的，不是简单的把公钥绑定到持有者身份上就完事了，还要包含序列号，用途，颁发者，有效时间等，把这些打成一个包再签名，完整的证明公钥关联的各种信息，形成数字证书

知名的CA全世界就这么几家，比如DigiCert，VeriSign，Entrust，Lets Encrypt, 它们签发的证书分DV，OV，EV 三种，区别于可信程度

DV最低，只有域名级别可信，背后是谁不知道，EV最高的，经过了法律审计的严格审查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）

这还是信任链的问题。小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 Root CA，就只能自己证明自己了，这个就叫“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了。

有了这个证书体系，操作系统和浏览器都内置了各大CA的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链一层层的验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的


### 证书体系的弱点

证书体系（PKI，Public Key Infrastructure）虽然是目前整个网络世界的安全基础设施，但绝对的安全是不存在的，它也有弱点，还是关键的“信任”二字。如果 CA 失误或者被欺骗，签发了错误的证书，虽然证书是真的，可它代表的网站却是假的。还有一种更危险的情况，CA 被黑客攻陷，或者 CA 有恶意，因为它（即根证书）是信任的源头，整个信任链里的所有证书也就都不可信了。这两种事情并不是“耸人听闻”，都曾经实际出现过。所以，需要再给证书体系打上一些补丁。针对第一种，开发出了 CRL（证书吊销列表，Certificate revocation list）和 OCSP（在线证书状态协议，Online Certificate Status Protocol），及时废止有问题的证书。对于第二种，因为涉及的证书太多，就只能操作系统或者浏览器从根上“下狠手”了，撤销对 CA 的信任，列入“黑名单”，这样它颁发的所有证书就都会被认为是不安全的。
