事实上 webgl 仅仅是一个光栅化引擎，如果想要完成更复杂的任务，取决于你的代码

webgl 在电脑的gpu中运行，因此你需要能够在gpu上运行的代码，这样的代码需要提供成对的方法，每对方法中一个叫顶点着色器一个叫片元着色器，并且使用一种类C的强制类型语言 GLSL，每一对组合起来称作一个 Program

顶点着色器的作用是计算顶点位置，根据计算出的一系列顶点位置，Webgl 可以对点，线和三角形在内的一些图元进行光栅化处理，当对这些图元进行光栅化处理的时候需要使用片元着色器方法，片元着色器的作用是计算出当前绘制图元中每个像素的颜色值

几乎整个webgl api 都是关于如何设置这些成对方法的状态值以及运行他们，对于想要绘制的每一个对象，都要先设置一些列状态值，然后通过调用 gl.drawArrays 或 gl.Elements 运行一个着色器方法对，使得你的着色器能够在GPU上运行

这些方法对所需要的任何数据都需要发送到GPU（显存）这里有着色器获取数据的4种方法

- 属性（attributes）和缓冲
缓冲是发送到GPU的一些二进制数据序列，通常情况下缓冲数据包括位置，法向量，纹理坐标，顶点颜色值等，但是你可以存储任何数据
属性用来指明怎么从缓冲中获取所需数据并将他们提供给顶点着色器，例如你可以在缓冲中用3个32位的浮点类型数据存储一个位置值，对于一个确切的属性你需要告诉它从哪个缓冲中获取数据，获取什么类型的数据（三个32位的浮点数据）， 起始偏移值是多少，到下一个位置的字节数是多少。

缓冲不是随意读取的，事实上顶点着色器运行的次数是一个指定的确切数字

你可以把绑定点想想成一个webgl内部的全局变量，首先绑定一个数据源到绑定点，然后可以引用绑定点执行的数据源
，
假设你正在画三角形，顶点着色器每完成三次顶点处理，webgl 就是用这三个顶点画成一个三角形它计算出三个顶点对应的像素后，就行进行光栅化这个三角形，光栅化其实就是 用像素画出来的花哨叫法，对于每一个像素，它会调用你的片元着色器询问你使用什么颜色，你通过给片段着色器的一个特殊变量 gl_GragColor 设置一个颜色值，实现自定义颜色


缓冲操作是在GPU上获取顶点和其他顶点数据的一种方式，gl.createBuffer 创建一个缓冲区（真实创建）gl.bindBuffer 是设置缓冲为当前使用的缓冲


webl gl 每次绘制都需要两个着色器，一个是顶点着色器和一个片元着色器，每一个着色器都是一个方法，一个顶点着色器和一个片元着色器连接在一起放在一个着色器程序中*或者只叫做程序，一个典型的webgl应用会有多个着色器程序

顶点着色器
一个顶点着色器的工作是生成裁剪空间坐标值，通常是以下的形式

每个顶点调用一次（顶点着色器），每次调用都需要设置一个特殊的全局变量gl_Position

该变量的值就是裁剪空间坐标值

顶点着色器需要的数据，可以通过以下三种方式获得
- attribute 属性（从缓冲区中获取的数据）
- uniforms 全局变量（在一次绘制中所有顶点保持一致值）
- Textures 纹理（从像素或纹理元素中获取的数据）

Attribute 属性

最常用的方法就是缓冲和属性，在工作原理中讲到了缓冲和属性，你可以创建缓冲

const buf = gl.createBuffer

将数据写入缓冲区

gl.bindBuffer(gl.ARRAY_BUFFER, buf)
gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW)

然后初始化的时候，在你制作的程序中找到数据的所在地址（理解为指针位置）

const positionLoc = gl.getAttribLocation(someShaderProgram, "a_position")

然后渲染的时候告诉WebGl怎么从缓冲区中获取数据传递给属性


uniForm 全局变量

全局变量在一次绘制过程中传递给着色器的值都是一样的，在下面的一个简单的例子中，用全局变量给顶点着色器添加了一个偏移量


在着色器中获取纹理信息，可以先创建一个 sampler2d 类型的全局变量 然后使用glsl的Texture纹理采样方法从纹理中提取信息

