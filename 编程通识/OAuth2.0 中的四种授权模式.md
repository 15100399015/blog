### 场景
【A服务（客户端）】需要用到【B服务（资源服务）】中的资源

### 授权码模式

1）【A服务（客户端）】将用户自动导航到【B服务（认证服务）】，这一步用户需要提供一个回调地址，以备【B服务（认证服务）】返回授权码使用
2）用户点击授权按钮表示让【A服务（客户端）】使用【B服务（资源服务）】，这一步需要用户登录B服务，也就是说用户需要具有B服务的使用权限
3）【B服务（认证服务）】生成授权码，授权码将通过第一步提供的回调地址，返回给【A服务（客户端）】，注意这个授权码并非是通行【B服务（资源服务）】的通行凭证
4）【A服务（认证服务）】携带上一步得到的授权码向【B服务（认证服务）】发送请求，获取通行凭证token
5）【B服务（认证服务）】给【A服务【认证服务】】返回令牌 token 和更新令牌 refresh token

### 简化模式
说明：简化模式中没有【A服务（认证服务）】这一部分，全部由【A服务（客户端）】与【B服务】进行交互，整个过程不再有授权码 token 直接暴露在浏览器

1）【A服务（客户端）】将用户自动导航到【B服务（认证服务）】这一步需要用户提供一个回调地址，以备【B服务（认证服务）】返回token使用，还会携带一个【A服务（客户端）】的状态标识
2）用户点击授权按钮表示让【A服务（客户端）】使用【B服务（资源服务）】，这一步需要用户登录到B服务，也就是说用户要事先具有B服务的使用权限
3）【B服务（认证服务）】生成通行令牌token。token通过第一步提供的回调地址，返回给【A服务（客户端）】

使用场景：适用于A服务没有服务器的情况，比如：纯手机小程序，JavaScript语言实现的网页插件等

### 密码模式

1）直接告诉【A服务（客户端）】自己的【B服务（认证服务）】的用户名和密码
2）【A服务（客户端）】携带【B服务（认证服务）】的用户名和密码向【B服务（认证服务）】发起请求获取token
3）【B服务（认证服务）】给【A服务（客户端）】颁发 token

使用场景：这种模式虽然简单，但是用户将B服务的用户名和密码暴露给了A服务，需要这两个服务信任度非常高才能使用

### 客户端模式

说明：这种模式其实已经不太属于OAuth2的范畴了，A服务完全脱离用户，以自己的身份去向B服务索取 token，换言之，用户无需具备B服务的使用权也可以，完全是A服务与B服务内部的交互，与用户无关了

1）A服务向B服务索取token
2）B服务返回token给A服务

使用场景：A服务本身需要B服务资源，与用户无关