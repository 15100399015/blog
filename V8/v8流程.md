解析代码需要时间，所以JavaScript引擎会尽可能避免完全解析代码源文件，另一方面在，在第一次用户访问中，页面中会有很多代码不会被执行到，比如通过用户交互行为触发的动作

正因为如此，所有主流浏览器都闲了惰性解析（lazy parsing）解析器不必为每个函数生成AST，而是可以决定预解析或完全解析它所遇到的函数

预解析会检查源代码的语法并抛出语法错误，但不会解析函数中变量的作用域生成AST，完全解析则将分析函数体并生成源代码对应的AST数据结构，相比正常解析，预解析的速度快了两倍

生成AST主要经过两个阶段：分词和语义分析，AST意在通过一种结构化的树形数据结构来描述源代码的具体语法组成，通常用于语法检查（静态代码分析），代码混淆，代码优化等


V8引入JIT（justin time）即时编译技术，通过ignition极限编译器快速生成字节码进行执行

字节码是机器码的抽象，如果字节码的设计与物理CPU的计算模型相同， 那么将字节码编译成机器代码会更加容易，这就是为什么解释器通常是寄存器或堆栈机器（ignition）是一个带有累加器的寄存器

和之前的极限编译器 Full-Codegen相比，ignition生成的体积更小的字节码（full-Codegen生成的是机器码），字节码可以直接被优化编译器 TurboFan用于生成图（TurboFan对代码的优化基于图），避免优化编译器在优化代码时需要对JavaScript源代码进行重新解析




垃圾回收

新生代使用复制算法
	form
	to
这是两个概念分区，并且只有一个激活状态，默认form激活，新创建的对象会首先放入到form分区中，然后如果一个对象经历过一次GC之后，这个对象存活了下来，就会从form分区复制到to分区，并激活to分区，如果在经历过一次GC这个对象还是没有被清除掉，则会被晋升到老年代
老生待使用标记清除算法
	
	老年代的GC会从根对象开始，依次往下遍历如果是能访问到的对象则表示对象存活，否则编辑为需要清除的，并且进行标记清楚之后，会进行内存整理（标记整理），将小的内存碎片合并


代码缓存三个级别
cold warm hot

用户首次请求js文件，浏览器会下载并将代码提供给v8进行编译，并缓存到磁盘中
第二次请求这个js文件的时候会直接从缓存中读取文件并交给v8进行编译执行，并且编译完后编译的代码会被反序列化，作为元数据附加到缓存的脚本文件中。
当用户第三次请求这个js文件的时候，浏览器会从缓存中读取文件和元数据信息，并交给v8，v8将跳过编译阶段，直接反序列化元数据