如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上

如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址

而实际的对象内容保存在堆中

对象的成员变量与对象本身一起存储在堆上，不管成员变量的类型是原生数值还是对象引用



总结一下，方法中使用的原生数据类型和对象引用地址在栈上存储

对象，对象成员与类定义，静态变量在堆上，

堆内存又被称为共享堆，堆中的所有对象，可以被所有线程访问，只要它们能拿到对象的引用地址

如果一个线程可以访问到某个对象的时候也就可以访问该对象的成员变量

如果两个线程同时调用某个对象的同一个方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的





没启动一个线程，JVM就会在栈空间分配对应的线程栈，比如1mb空间

线程栈叫做Java方法栈，如果使用了 JNI 方法则会分配一个单独的本地方法栈

线程执行过程中，一般会有多个方法组成调用栈（Stack Trace）比如 A 调用 B B 调用 C 就会创建一个对应的栈帧



栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本上就能确定

比如返回值，需要一个存储空间存放，每个局部变量都需要对应的内存地址，空间，此外还有个指令使用的操作数栈，以及class指针，



堆内存是所有线程共享共用的内存空间，JVM将 Heap 内存分为 

- 年轻代
- 老年代

两部分

年轻代还划分为三个内存池，

- 新生代
- 存活区



所有的对象（包括内部的实例成员变量），static，变量以及数组，都必须存放到堆内存中

局部变量，方法的形参/入参，异常处理语句的入参不允许在线程间共享，所以不受内存模型的影响

多线程同时对一个变量访问时【读取/写入】，这时候只要有某个线程执行的是写操作，那么这种现象被称之为 冲突

可以被其他线程影响或感知的操作，称为线程间的交互行为，可分为：读取，写入，同步操作，外部操作等等，其中同步操作包括：对Volatile 变量的读写，对管程（monitor）的锁定与解锁，线程的其实操作，线程的结尾操作等，外部操作则是对线程执行环境之外的操作，比如停止其他线程等等

JMM 规范的是





永久代与元空间有千丝万缕的联系，受限来看下永久代

永久代更规范的名字叫方法区，永久代是方法区的一种实现方式，方法区是java规范中定义的，只有hotspot才有永久代，之所以叫它永久代是因为垃圾回收效果很差，大部分的数据会一直存在知道程序停止运行

永久代里一版存储类相关信息，比如类常量，字符串常量，方法代码，类的定义数据等，如果要回收永久代的空间，需要将类卸载，而类卸载的条件非常苛刻，所以一版回收很难，当程序中有大量动态生成类的时候，这些类信息都要存储在永久代，很容器造成方法区溢出

### 元空间

在Java8里面，元空间替代了永久代，原来用于存放永久代的类信息现在放到了元空间，我们再也看不到 PermGen file error 的异常了

本质上元空间也是方法区的一种实现

元空间是用来存放classMetadata的，class metadata 用于记录一个java 类在JVM中的信息，包括但不限于JVM class file format 的运行时数据

- Klass 结构 这个非常重要，把他理解为一个java类在虚拟机内部的表示
- method metadata 包括方法的字节码，局部变量表，异常表，参数信息等
- 注解
- 方法计数器
- 其他

虽然每个 Java 类都关联了一个java.lang.Class 的实例，而且它是一个储存在堆中的Java对象，但是类的class metadata 不是一个java 对象，他不在

