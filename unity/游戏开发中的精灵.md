游戏编程中的精灵（split）意思：精灵也就是精灵对象，就是游戏中的一个具有行为的元素，以超级玛丽为例，玛丽，敌人都算是一个精灵对象，精灵对象如一下几个特点

unity 中 sprite 是图片精灵的意思，图片精灵是用来绘制图集的控件，精灵可以在一张大图中去截取一部分（大图的就是整体图像的集合（atlas）而截取的小图就是一个精灵），然后给精灵命名，使用时通过精灵的名称就能直接绘制，并且精灵还可以用来制作动画

游戏发展早期，c甚至汇编当道，复杂的游戏逻辑（玩家操作，攻击技能，伤害判定，各种特殊的技能/状态逻辑，等等）想要有条不紊的管理起来，随时间流逝均匀可控的运作，同时又要尽量优化性能，难度和复杂度是非常高的。因此就有了精灵的抽象，游戏里一切能感知时间流逝，具有坐标位置的，都是精灵

你看一下子就抓住了两个根本

- 有坐标信息
- 能感知时间流逝

一旦抓住了这两个根本，事情就容易起来了

我们可以设计一个定时器，周期性的调用和精灵绑定的处理函数，实际上，这个处理函数是一个 dispatcher, 它负责转调我们写的一切动画以及碰撞判定等逻辑的处理函数

所以这些函数都能接受 interval 参数，比如让精灵按贝塞尔曲线运动的函数就是用interval乘以运行速率，然后改写精灵的坐标信息，同样的，动画呢，就是按照interval的节律缩放扭曲图片或者改变它的颜色（或者基于interval把一组图片换来换去，从而实现走路、放大招等效果）。

注意精灵是可以没有对应的图片的，比如我们要在进门处放个陷阱，那就是一个和门口坐标重叠的，不可见的 “触发器trigger”，当碰撞检测发现游戏物体和这个 “触发器精灵”，坐标重合时，就是调用对应的 trigger

换句话说，这里用c甚至汇编实现的一个原始而精巧的继承体系，它的根是精灵这个基类，提供坐标这个公开数据成员和 dispatcher 时钟信息的接口，然后是支持碰撞检测以及提供接受碰撞事件并加以处理的接口的继承类和支持动画的继承类以及其他各种继承类

至于为什么叫精灵，大概是因为它只能感知有位置，却未必有实体吧，在西方传说里，精灵sprite本来就是有魔力的，基于虚实之间的幻想角色

一旦有了这个抽象，那么无论声音还是图像，无论是软件还是硬件优化，就都要以精灵为中心了：

- 负责游戏性循着精灵这条线更改角色位置，检测碰撞，触发相关处理逻辑，
- 负责画面的也循着精灵这条线，更新屏幕显示，优化图形性能，
- 负责声音的呢。同样也循着精灵这条线，根据距离画面焦点的远近改变不同的声源和声音大小，以及是否考虑应该添加滤波/回音等效果，
- 负责剧情的同样可以把文字/过场动画/事件触发等绑到精灵上，设定触发条件即可，等等

总之，每个人只关注自己需要关注的那个侧面，完全可以忽视其他东西的存在，这样不管游戏多么复杂，世界多么宏大，一切都可以井井有条的解决

注意这个先后顺序，程序员设计的东西，肯定是以便利程序员自己为最优先	

先有一个合理高效的架构，然后一切就可以基于这个架构提供方便

就好像是计算机3D图形先把3D真实感图形渲染以面片为中心、然后硬件设计（显卡/GPU）才提供了迎合这个抽象的渲染体系；并不是硬件先弄出来面片，然后程序员们一阵焦头烂额手忙脚乱的往面片迁移……肯定不是这个过程，对吧。

换句话说，硬件支持可以证明一种做法的流行——流行到通过硬件管线直接支持——却几乎不可能是这种做法的来源（都出硬件支持了，可想而知这种设计在硬件出来之前有多流行）。

另一个，因为大多数人只负责自己那一块，很容易局限于“在我的领域，XX事是怎么怎么来的”。这大概就是高票二位大佬掐架的原因。

但游戏开发是个很复杂的工作，不可能迁就于某个单一方面。比如在3D游戏逻辑开发里就没有“面片”，那是建模和渲染玩的，不会“侵染”游戏逻辑开发过程，对吧。

同样的，2D游戏开发，精灵是从软件架构来的；但这个架构在设计时，一定综合考虑了图像渲染、游戏逻辑等诸多方面，最终才决定“同时向图像组和游戏逻辑组开放sprite这个概念”——也只有站在总体架构的角度，sprite这个术语才是贴切的：如果是图像处理方单独决定的，那他们肯定不会叫它sprite。这个词和他们做的事（合成活动图片到背景）有半点关系吗？

当然，因为语言层面没有面向对象的支持，这个设计只能通过以强制类型变换为核心的各种奇技淫巧实现。到了面向对象时代后，这套体系就沿用下来了；后来大概是为了区分吧，2D游戏仍然沿用精灵这个术语；而3D游戏就改名叫GameObject，不再使用“精灵”这个说法（但一切GameObject仍然有坐标有transform，哪怕它只是个计分牌、只关心屏幕坐标）。