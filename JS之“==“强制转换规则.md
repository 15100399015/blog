### 隐式类型转换规则

> Javascript 中类型转换只有三种，
>
> - 转成数字
> - 转成布尔值
> - 转成字符串

#### 加法运算操作符

加号运算操作符在JavaScript可以作为数字的相加，也可用于字符串的连接符，所以需要特别注意，其中的转换规则是：当加号两边都是数字的时候执行加法，否则一律连接，所以加号操作符的规则分几种情况

- 如果有一侧为string

加法运算在这种情况下如果有一侧为String类型，则将另一侧转为字符串，最后链接起来，注意：对象，数组，函数，布尔, 则先调用toString()方法取得字符串值，调用其valueOf()方法，然后在拼接到一起。对于undefined和null，分别调用String()显式转换为字符串。

- 如果有一侧是Number类型，另一侧为原始类型则将元素类型转换为Number类型
- 如果有一侧为Number类型，另一侧为引用类型，将引用类型转换为Number类型都转换为字符串进行拼接

以上三点优先级从高到低



作者：_littleTank_
链接：https://www.jianshu.com/p/72076cb2eed1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```javascript
[] == ![] // 为什么是true？
```

`==` 在进行比较的时候会进行强制转换，规则如下

![在这里插入图片描述](https://liangx-gallery.oss-cn-beijing.aliyuncs.com/202304071113353.png)

所以流程是

```
// [] == false
// [] == 0
// "" == 0
// 0 == 0
// true
```

> 为什么 0.1 + 0.2 != 0.3
>
> number类型运算都要想将其转化为二进制，将二进制运算，运算的结果再转化为十进制，因为number是64位双精度，小数部分只有52位，但0.1转化成为二进制是无限循环的，所以四舍五入了，这里就发生了精度丢失，0.1的二进制和0.2的二进制相加需要保留有效数字，所以又发生了精度丢失，所以结果为0.300000000000004，所以为false，而0.2+0.3恰好两个转化成为二进制和相加的过程都不会发生精度丢失，所以为true，

> 浮点数本来在计算机里面就不准的，除非能够直接能够用二进制表示的数，比如0.5、0.25这种是精确的，其他都是一个近似值，但近似值也是有规则的，比如0.2，计算机里面肯能在最小精度范围内找到了最接近0.2的两个数，其中一个比0.2大，另一个比0.2小。计算机内部会选一个它认为最接近的数。 比如： 0.1 取的 0.10000000000000000555111512 0.2 取的 0.2000000000000000111022302 0.3 取的 0.299999999999999988897769 0.1+0.2 从表面上看就大于 0.3 了，和0.3的实际值肯定不相等。 01.+0.2 计算出来的值是 0.3000000000000000444089209 0.2+0.3 计算出来的值正巧和 0.5 的值一样，所以是相等的。 除了 0.1+0.2 还有很多情况可以比较出来是不相等的，比如 0.1+0.7、0.3+0.6 等 要看计算机里面到底表示多少可以把浮点数取一个比较长的精度看一下就知道了。用 Number(0.3+0.6).toPrecision(100)  这个就能看到精度为100的情况。